#include "stdafx.h"
#include "DES.h"
/* 本文件的函数声明 ----------------------------------------------------------*/

void ByteToBit(u8 *DatOut, u8 *DatIn, u8 Num); // 字节到位
void BitToByte(u8 *DatOut, u8 *DatIn, u8 Num);
void TablePermute(u8 *DatOut, u8 *DatIn, const u8 *Table, u8 Num); // 位表置换函数
void LoopMove(u8 *DatIn, int Len, u8 Num);        // 循环左移 Len长度 Num移动位数
void Xor(u8 *DatA, u8 *DatB, u8 Num);         // 异或函数
void S_Change(u8 DatOut[32], u8 DatIn[48]);   // S盒变换
void F_Change(u8 DatIn[32], u8 DatKi[48]);    // F函数                                 
void SetKey(u8 *KeyIn, DES_SubKeyBitStruct *SubKey);                      // 设置密钥
int DES_Cal(u8 *BlockIn, DES_SubKeyBitStruct *SubKey, u8 *BlockOut, u8 IsDecrypt);
void DES_MakeSubKey(u8 *Key, DES_SubKeyBitStruct *SubKey)
{
	SetKey(Key, SubKey);
}

/*-------------------------------------------------------------
置换表
-------------------------------------------------------------*/


// 对明文执行IP置换得到L0,R0 （L左32位,R右32位）               [明文操作]
u8 IP_Table[64] = {
	58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
	62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
	57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
	61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7
};

// 对迭代后的L16,R16执行IP逆置换,输出密文
const u8 IPR_Table[64] = {
	40, 8, 48, 16, 56, 24, 64, 32,
	39, 7, 47, 15, 55, 23, 63, 31,
	38, 6, 46, 14, 54, 22, 62, 30,
	37, 5, 45, 13, 53, 21, 61, 29,
	36, 4, 44, 12, 52, 20, 60, 28,
	35, 3, 43, 11, 51, 19, 59, 27,
	34, 2, 42, 10, 50, 18, 58, 26,
	33, 1, 41, 9, 49, 17, 57, 25
};

/*--------------------------- 迭代法则 ----------------------------*/

// F函数,32位的R0进行E变换,扩为48位输出 (R1~R16)        [备用A]  [明文操作]
static u8 E_Table[48] = {
	32, 1, 2, 3, 4, 5,
	4, 5, 6, 7, 8, 9,
	8, 9, 10, 11, 12, 13,
	12, 13, 14, 15, 16, 17,
	16, 17, 18, 19, 20, 21,
	20, 21, 22, 23, 24, 25,
	24, 25, 26, 27, 28, 29,
	28, 29, 30, 31, 32, 1
};

// 子密钥K(i)的获取 密钥为K 抛弃第6,16,24,32,40,48,64位          [密钥操作]
// 用PC1选位 分为 前28位C0,后28位D0 两部分 
static u8 PC1_Table[56] = {
	57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18,
	10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36,
	63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22,
	14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4
};

// 对C0,D0分别进行左移,共16次,左移位数与下面对应                 [密钥操作]
static u8 Move_Table[16] = {
	1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
};

// C1,D1为第一次左移后得到,进行PC2选位,得到48位输出K1   [备用B]   [密钥操作]    
static u8 PC2_Table[48] = {
	14, 17, 11, 24, 1, 5,
	3, 28, 15, 6, 21, 10,
	23, 19, 12, 4, 26, 8,
	16, 7, 27, 20, 13, 2,
	41, 52, 31, 37, 47, 55,
	30, 40, 51, 45, 33, 48,
	44, 49, 39, 56, 34, 53,
	46, 42, 50, 36, 29, 32
};

/*------------- F函数 备用A和备用B 异或 得到48位输出 ---------------*/

// 异或后的结果48位分为8组,每组6位,作为8个S盒的输入             [组合操作]
// S盒以6位作为输入(8组),4位作为输出(4*(8组)=32位)
// S工作原理 假设输入为A=abcdef ,则bcde所代表的数是0-15之间的
// 一个数记为 X=bcde ,af代表的是0-3之间的一个数,记为 Y=af
// 在S1的X列,Y行找到一个数Value,它在0-15之间,可以用二进制表示
// 所以为4bit (共32位) 
static u8 S_Box[8][4][16] = {
	//S1
	14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
	0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
	4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
	15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13,
	//S2
	15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
	3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
	0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
	13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9,
	//S3
	10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
	13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
	13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
	1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12,
	//S4
	7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
	13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
	10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
	3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14,
	//S5
	2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
	14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
	4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
	11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3,
	//S6
	12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
	10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,    //S6表错误
	9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
	4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13,
	//S7
	4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
	13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
	1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
	6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12,
	//S8
	13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
	1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
	7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
	2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11
};

// F函数 最后第二步,对S盒输出的32进行P置换                     [组合操作]
// 输出的值参与一次迭代:
// L(i)=R(i-1)
// R(i)=L(i-1)^f(R(i-1),K(i)) 异或
static u8 P_Table[32] = {
	16, 7, 20, 21,
	29, 12, 28, 17,
	1, 15, 23, 26,
	5, 18, 31, 10,
	2, 8, 24, 14,
	32, 27, 3, 9,
	19, 13, 30, 6,
	22, 11, 4, 25
};



/*******************************************************************************
* 函数名           : ByteToBit
* 描述             : 字节转换成位，共64位
* 参数             : 无
* 输入             : DatIn：要转换的字节 num：转换长度
* 输出             : DatOut：存放转换成二进制的数据
* 返回             : 无
*******************************************************************************/
void ByteToBit(u8 *DatOut, u8 *DatIn, u8 Num)       // OK
{
	u8 i;
	for (i = 0; i < Num; i++)
	{
		DatOut[i] = (DatIn[i / 8] & 0x80) ? 1 : 0;
		DatIn[i / 8] = DatIn[i / 8] << 1;
	}
}



/*******************************************************************************
* 函数名           : BitToHex
* 描述             : 二进制密文转换为十六进制，共16个字符
* 参数             : 无
* 输入             : DatIn：要转换的二进制密文数据 num：转换长度
* 输出             : DatOut：存放转换成十六进制的密文数据
* 返回             : 无
*******************************************************************************/
void BitToByte(u8 *DatOut, u8 *DatIn, u8 Num)
{
	u8 i = 0, j = 0, k;
	while (i < Num)
	{
		DatOut[j] = 0;
		for (k = i; k < (i + 8);k++)
		{
			DatOut[j] <<= 1;
			DatOut[j] |= ((DatIn[k] == 1) ? 1 : 0);
		}
		i += 8;
		j++;
	}
}


/*******************************************************************************
* 函数名           : TablePermute
* 描述             : PC-1置换
* 参数             : 无
* 输入             : DatIn：要置换的二进制数据 Table：PC-1置换表 num：置换的长度(56)
* 输出             : DatOut：存放置换后的二进制数据
* 返回             : 无
*******************************************************************************/
void TablePermute(u8 *DatOut, u8 *DatIn, const u8 *Table, u8 Num)
{
	u8 i;
	u8 Temp[256]={0};

	for (i = 0; i < Num; i++)               // Num为置换的长度
	{
		Temp[i] = DatIn[Table[i] - 1];  // 原来的数据按对应的表上的位置排列
	}
	memcpy(DatOut, Temp, Num);       // 把缓存Temp的值赋给DatOut
}


/*******************************************************************************
* 函数名           : LoopMove
* 描述             : 子密钥Cn，Dn的移位操作
* 参数             : 无
* 输入             : DatIn：移位前数据地址 Len：移位前数据长度 PC-1置换表 Num：要移Num位(具体查阅移位表)
* 输出             : DatOut：存放置换后的二进制数据
* 返回             : 无
*******************************************************************************/
void LoopMove(u8 *DatIn, int Len, u8 Num) // 循环左移 Len数据长度 Num移动位数
{
	u8 Temp[256]={0};            //static u8 Temp[256]={0};    // 缓存   OK

	memcpy(Temp, DatIn, Num);           // 将数据最左边的Num位(被移出去的)存入Temp
	memcpy(DatIn, DatIn + Num, Len - Num);  // 将数据左边开始的第Num移入原来的空间
	memcpy(DatIn + Len - Num, Temp, Num);   // 将缓存中移出去的数据加到最右边
}


/*******************************************************************************
* 函数名           : Xor
* 描述             : E(Rn-1)异或Kn
* 参数             : 无
* 输入             : DatA：E(Rn-1)数据的地址 DatB：新密钥Kn数据的地址 Num：位数
* 输出             : DatA：异或后的结果
* 返回             : 无
*******************************************************************************/
void Xor(u8 *DatA, u8 *DatB, u8 Num)           // 异或函数
{
	u8 i;
	for (i = 0; i < Num; i++)
	{
		DatA[i] = DatA[i] ^ DatB[i];                  // 异或
	}
}


/*******************************************************************************
* 函数名           : S_Change
* 描述             : S盒操作，将8组6比特的数据转换为8组4比特的数据
* 参数             : 无
* 输入             : DatIn：8组6比特的数据(即异或后的结果)
* 输出             : DatOut：8组4比特的数据
* 返回             : 无
*******************************************************************************/
void S_Change(u8 DatOut[32], u8 DatIn[48])     // S盒变换
{
	u8 i, j;
	u8 X, Y;                                      // i为8个S盒
	for (i = 0, Y = 0, X = 0; i < 8; i++, DatIn += 6, DatOut += 4)              // 每执行一次,输入数据偏移6位
	{                                                       // 每执行一次,输出数据偏移4位
		Y = (DatIn[0] << 1) + DatIn[5];                           // af代表第几行--第1位和最后1位为S盒的行
		X = (DatIn[1] << 3) + (DatIn[2] << 2) + (DatIn[3] << 1) + DatIn[4]; // bcde代表第几列--中间4位为S盒的列
		for (j = 0; j < 4; j++)
		{
			DatOut[j] = ((S_Box[i][Y][X] << j) & 0x08) >> 3;// 把找到的点数据换为二进制
		}
	}
}


/*******************************************************************************
* 函数名           : F_Change
* 描述             : F函数工作过程：1.通过E表将32位Rn-1拓展成48位 2.对输出E(Rn-1) 和秘钥Kn执行异或运算 3.将2步的结果通过S盒将8组6比特变成8组4比特 4.将3结果进行P变换
* 参数             : 无
* 输入             : DatIn：Rn-1 DatKi：新密钥Kn
* 输出             : DatIn:最后P置换的结果
* 返回             : 无
*******************************************************************************/
void F_Change(u8 DatIn[32], u8 DatKi[48])       // F函数
{
	u8 MiR[48] = { 0 };              // 输入32位通过E选位变为48位

	TablePermute(MiR, DatIn, E_Table, 48);   //--OK

	Xor(MiR, DatKi, 48);                    // 和子密钥异或--OK

	S_Change(DatIn, MiR);                  // S盒变换--OK

	TablePermute(DatIn, DatIn, P_Table, 32); // P置换后输出--OK
}

/*******************************************************************************
* 函数名           : SetKey
* 描述             : 产生子密钥：1.56位的PC-1置换 2.拆分密钥为C0,D0，各28位 3.对Cn，Dn按表移位 4.拼凑密钥Cn，Dn组成Kn新密钥
* 参数             : 无
* 输入             : KeyIn：8字节的原始密钥
* 输出             : SubKey：新密钥Kn
* 返回             : 无
*******************************************************************************/
void SetKey(u8 *KeyIn, DES_SubKeyBitStruct *SubKey)                          // 设置密钥 获取子密钥Ki
{
	u8 i;
	u8 KeyBit[64] = { 0 };                       // 密钥二进制存储空间
	u8 *KiL = &KeyBit[0], *KiR = &KeyBit[28];  // 前28,后28共56位

	ByteToBit(KeyBit, KeyIn, 64);                    // 把密钥转为二进制存入KeyBit--ok

	TablePermute(KeyBit, KeyBit, PC1_Table, 56);      // PC1表置换 56次--ok

	//16轮迭代
	for (i = 0; i<16; i++)    //k1-k16
	{
		LoopMove(KiL, 28, Move_Table[i]);       // 前28位左移

		LoopMove(KiR, 28, Move_Table[i]);       // 后28位左移 -- OK

		TablePermute(SubKey[i].KeyBit, KeyBit, PC2_Table, 48);        //PC-2置换-- OK

		// 二维数组 SubKey[i]为每一行起始地址
		// 每移一次位进行PC2置换得 Ki 48位
	}
}

int DES_Cal(u8 *BlockIn, DES_SubKeyBitStruct *SubKey, u8 *BlockOut, u8 IsDecrypt)
{
	u8 i;// 字节输入 Bin运算 Hex输出
	u8 MesBit[64] = { 0 };        // 明文二进制存储空间 64位
	u8 Temp[32] = { 0 };
	u8 *MiL = &MesBit[0], *MiR = &MesBit[32]; // 前32位 后32位
	ByteToBit(MesBit, BlockIn, 64);                 // 把明文换成二进制存入MesBit--OK
	TablePermute(MesBit, MesBit, IP_Table, 64);    // IP置换--OK
	if (IsDecrypt)
	{
		for (i = 0; i < 16; i++)                            // 迭代16次
		{
			memcpy(Temp, MiR, 32);             // 临时存储--公式(a)
			F_Change(MiR, SubKey[15 - i].KeyBit);           // F函数变换
			Xor(MiR, MiL, 32);                   // 得到Ri--公式(b)
			memcpy(MiL, Temp, 32);             // 得到Li ---OK
		}
	}
	else
	{
		for (i = 0; i < 16; i++)                            // 迭代16次
		{
			memcpy(Temp, MiR, 32);             // 临时存储--公式(a)
			F_Change(MiR, SubKey[i].KeyBit);           // F函数变换
			Xor(MiR, MiL, 32);                   // 得到Ri--公式(b)
			memcpy(MiL, Temp, 32);             // 得到Li ---OK
		}
	}

	memcpy(Temp, MiR, 32);
	memcpy(MiR, MiL, 32);
	memcpy(MiL, Temp, 32);  //最后的R16L16不调换

	TablePermute(MesBit, MesBit, IPR_Table, 64);   //得到R16L16后进行IP-1(IP逆变换)
	BitToByte(BlockOut, MesBit, 64);
	return 0;
}

/*******************************************************************************
* 函数名           : PlayDes
* 描述             : 加密数据过程：1.IP置换 2.16轮迭代 a)Ln=Rn-1
b)Rn=Ln-1+f(Rn-1,Kn)
* 参数             : 无
* 输入             : MesIn：8字节明文
* 输出             : MesOut：存放DES运算后8字节的密文
* 返回             : 无
*******************************************************************************/
// void PlayDes(u8 MesOut[8], u8 MesIn[8])  // 执行DES加密
// {
// 	u8 i;// 字节输入 Bin运算 Hex输出
// 	u8 MesBit[64] = { 0 };        // 明文二进制存储空间 64位
// 	u8 Temp[32] = { 0 };
// 	u8 *MiL = &MesBit[0], *MiR = &MesBit[32]; // 前32位 后32位
// 
// 	ByteToBit(MesBit, MesIn, 64);                 // 把明文换成二进制存入MesBit--OK
// 
// 	TablePermute(MesBit, MesBit, IP_Table, 64);    // IP置换--OK
// 
// 	for (i = 0; i<16; i++)                            // 迭代16次
// 	{
// 		memcpy(Temp, MiR, 32);             // 临时存储--公式(a)
// 		F_Change(MiR, SubKey[i]);           // F函数变换
// 		Xor(MiR, MiL, 32);                   // 得到Ri--公式(b)
// 		memcpy(MiL, Temp, 32);             // 得到Li ---OK
// 	}
// 
// 	memcpy(Temp, MiR, 32);
// 	memcpy(MiR, MiL, 32);
// 	memcpy(MiL, Temp, 32);  //最后的R16L16不调换
// 
// 	TablePermute(MesBit, MesBit, IPR_Table, 64);   //得到R16L16后进行IP-1(IP逆变换)
// 
// }


/*******************************************************************************
* 函数名           : KickDes
* 描述             : 加密数据过程：1.IP置换 2.16轮迭代 a)Ln=Rn-1
b)Rn=Ln-1+f(Rn-1,Kn)
* 参数             : 无
* 输入             : MesIn：8字节明文
* 输出             : MesOut：存放DES运算后8字节的密文
* 返回             : 无
*******************************************************************************/
/*
void KickDes(u8 MesOut[8],u8 MesIn[8])       // 执行DES解密
{                                               // Hex输入 Bin运算 字节输出
int i=0;
static u8 MesBit[64]={0};        // 密文二进制存储空间 64位
static u8 Temp[32]={0};
static u8 *MiL=&MesBit[0],*MiR=&MesBit[32]; // 前32位 后32位
HexToBit(MesBit,MesIn,64);                 // 把密文换成二进制存入MesBit
TablePermute(MesBit,MesBit,IP_Table,64);    // IP置换
for(i=15;i>=0;i--)
{
BitsCopy(Temp,MiL,32);
F_Change(MiL,SubKey[i]);
Xor(MiL,MiR,32);
BitsCopy(MiR,Temp,32);
}
TablePermute(MesBit,MesBit,IPR_Table,64);
BitToByte(MesOut,MesBit,64);
}
*/